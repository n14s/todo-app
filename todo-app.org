#+TITLE: Todo App

* Why a Todo App
** Easy existing UI. Can fokus on the dev process and the other technical parts (data handling)
** Offers knowledge needed for building own fullstack apps, especially CRUD concepts


* Architecture
** Frontend/Web: Svelte
** Hosting/API: Svelte Kit
*** Prisma
** DB: Postgres
** Deployment (Web): Vercel
** Deployment (DB): Railway
** Dev: Gitpod

** Interactions
*** Svelte - Svelte Kit
- Svelte Kit exposes APIs
- Svelte Frontend requests GET /todos to Svelte Kit
- Svelte Kit responses with JSON

*** Svelte Kit (+Prisma) - Postgres
- Svelte Kit requests data from Postgres
- Prisma acts as a translator beween JS objects and SQL commands

* Dev Process
[[id:b33d4592-6d82-4b38-93a0-d5abadfce1ba][Generell Dev Process documented here]]

** Create issue to add feature
- Create branch for issue/feature
- Can use [[id:616143af-d87d-4aaa-a429-5c9377f58c74][Gitpod]]  for an encapsulated environment for issue

** How to run
*** npm install
*** npm run dev

* Svelte
Svelte compiles svelte files into pure javascript. Thus very little overhead and good performance on browserside.
** Files
*** package.json
**** scripts
**** devDependencies
- no prod-dependencies for svelte needed, they are just devdependencies since svelte is a compiler that translates the code to js
*** svelte.config.js
**** preprocess
**** kit
***** adapter
- where/how to host app: svelte-auto, vercel, cloudflare
***** target
- where is app rendered
*** src/app.html
**** div id=svelte %svelte.body%
- this is where index.svelte is rendered into
*** src/routes/index.svelte
- index = landing page
- apply html, js, or css specific for this route, i.o.w. it only applies to this component
*** src/routes/otherpage.svelte
- file based routing (http://dings.de/otherpage)
- other pages can be created here

*** __layout.svelte
- apply comon html, js or css to all routes, eg. import app.css within script tags


*** tsconfig.json
- is populated by svelte team (remember the option use ts in the beginning ;))

*** styles
**** src/app.css
***** :root{}
- class selector, equivalent to html{}
- more autority than html: can override html properties even if declared before

* HTML
* CSS
** size
*** em vs rem
- em: size rel. to parent font size
- rem: size rel. to root font size
- default font size of html object is 16
*** height
- main goal: let html and body element grow with content
- mordern technique: only style body to use height: 100vh
[[cite:&HTMLVsBody2021]]
*** width
- either ignore, because defaults to 100%
- or remove margins and set to 100% afterwards
** position
*** margin
- position or center elements
- top left bottom right
- 4rem auto 0 auto, centers the element horizontally with a margin at the top
** media queries (@media)
- conditionally apply style
*** example
#+begin_src css
@media (min-width 720) {
    h1 {
        font-size: 2.4rem;
            }
}
#+end_src

- if condition width>720, then setting font size of h1 applies

** change upon action
- only applys css if action is true

#+begin_src css
my-element:focus-visible {
    font-color: red
}
#+end_src

** selectors
*** type
html element type
#+begin_src css
<div>
div { font-color: blue}
#+end_src
*** class
group added to different elements
#+begin_src css
<div class="myclass">
.myclass { font-color: blue}
#+end_src
*** id
specific single element
#+begin_src css
<div id="myid">
#myid { font-color: blue}
#+end_src

** specifity
- styles of higher specifity override others
*** !important
- high specifity can be overridden with !important style decoration

** sibling/child (+ / >)
*** sibling selector
#+begin_src css
h1 + p {}
#+end_src
- applies style to any p that is a direct sibling of h1
*** child selector
#+begin_src css
h1 > p {}
#+end_src
- applies style to any p that is a direct child of h1
** dynamic styling
- htmls class name can get added dynamically
- css selector may apply on added class only, thus only activating when class name is added
 #+begin_src css
.done .toggle {
    color: red
}
<h1 class="toggle"> or
<h1 class="done toggle"> after adding done dynamically
#+end_src

* form data (action, method)
- send data defined in forms from client to server
- action: where sending data, eg. endpoint "/data.json"
- method: request method, eg. "get", "post"

* API in Svelte
** Define route through file/folder name
- routes/*.svelte default to html website retrieved with get
- routes/<endpoint>/index.json.ts create endpoint for the <endpoint> folder name

** Define API: Create Crud methods
- create and export arrow/lambda function for get, post, etc
- return object; else it returns 404 to user
- use typescript, in this case the imported RequestHandler, to get goodies like autocomplete/suggestions/helpinfo

#+begin_src js
export const get : RequestHandler = () => {
    return {
        status: 200,
        body: "Hello to API"
    }
}
#+end_src

- use formData as an interface to form, field and values in html, eg. to get the text inserted in text field of form
#+begin_src js
export const post : RequestHandler = await ({request}) => {
    const formData = await request.formData
    console.log(formData.get(''))
}
#+end_src

- ({request}) is object deconstruction. makes nested request field/object usable in function declarion

** Call API
- fetch endpoint
- use res field/methods for desired behavior
#+begin_src js
const res = await fetch(/<endpoint>)
console.log(res.json())
#+end_src
** Use 303 (redirect) on post request
- post to an "/<endpoint>" endpoint, would route you to that endpoint upon a 200
- most of the times you want to stay on the current site
- use status: 303 to redirect to current site, or defined by header: { location: "/"}

** _api helper file
- share objects on different endpoints by storing it in a helper file
- place api logic in _api file
- svelte ignores _<file> in routes (doesnt create site or endpoint)

** route with dynamic path
- routes with variable path can be create on runtime
- variable part with bracekts ~[uid].json.ts~
- can be populated with ~params.~

** method override remove, put, etc
- remove, etc dont exist as default form request types
- when defining route in ts use "del" as http verb (delete is reserved in js)
- define methodOverride in svelte.config.js
* variables and scopes
** var
- global scope
- scope can lead to side effects/bugs
** let
- block scope
- preferable since js 6
** const
- black scope
- cannot be updated
- object fields cant be updated, but object field values can

** hoisting
- execution context property: compile phase runs before execution phase
-
 compile phase includes declarations, eg: ~var number;~
- execution phase includes assignments, eg: ~number = 42;~
- thus the following code behaves:
#+begin_src js
function greet() {
    greeting = "hi";
    console.log(greeting);
    var greeting;
}
greet(); // hi
#+end_src

- also works for function declaration
- hoisted var is assigned undefined, hoisted let, const are not assigned


* loops
** for in
- loops over array randomly
** for of
- retains the array order while looping
** each (svelte only)
#+begin_src svelte
{#each todos as todo}
console.log(todo)
{/each}
#+end_src

* reactivity $:
- is triggered by assignment of var, eg. count
- array functions like push dont trigger reactivity
** declarations
#+begin_src js
count = 0 ;
$: double = count * 2

count = 5 // double = 10
#+end_src

- double always updates upon count change
** statements
~$: console.log(count)~
- statement is triggered upon count change

* Properties in Svelte
- props are used to pass data between components

~export let count~ defines prop count that can be filled from other component
prop count is then usually used in the html


* Typescript
** handle exceptions to function parameter type
- some function may need more gerenell objects to be passed
- use the lowest common denominator object, eg. Record<string, unknown>
- correct typescripts type errors by casting type with <var> as <type>, eg. todo.text as string

* JS
** map as match replace
#+begin_src js
todos = todos.map(todo => {
                if (todo.uid === requestEvent.params.uid) {
                    todo.text = data.text as string
                }
            return todo
            })
#+end_src
** filter
*** rm todos that dont match
#+begin_src js
todos = todos.filter( todo => todo.uid !== requestEvent.params.uid)
#+end_src
